# Arquitectura de Software de NADIR

La arquitectura de NADIR ha sido concebida siguiendo los principios de la Ingeniería de Software moderna aplicados al ecosistema Android priorizando la separación de responsabilidades a través de Clean Architecture y la escalabilidad modular. Este enfoque asegura que el sistema sea resistente a los cambios tecnológicos y fácilmente mantenible a lo largo del tiempo separando claramente la lógica de negocio de los detalles de implementación del framework.

En el nivel más alto la estructura del proyecto se organiza bajo el paradigma de modelado de dominio donde cada funcionalidad principal como la gestión de sesiones o la calibración del sensor se encapsula en módulos independientes. Esta estrategia de diseño conocida como Vertical Slicing o segmentación vertical permite que los desarrolladores trabajen en características específicas sin afectar a otras áreas del sistema reduciendo los conflictos en el control de versiones y facilitando las pruebas aisladas. A diferencia de las arquitecturas tradicionales por capas horizontales donde todos los modelos de datos se agrupan juntos el enfoque vertical mantiene cohesivas todas las clases relacionadas con una misma característica promoviendo un acoplamiento bajo y una cohesión alta.

El patrón arquitectónico que gobierna la capa de presentación es Model View ViewModel o MVVM el cual ha demostrado ser el estándar de facto para el desarrollo en Android moderno. En esta configuración la Vista representada por las funciones componibles de Jetpack Compose es un consumidor pasivo de datos que reacciona a los cambios de estado. No contiene lógica de negocio compleja sino que se limita a renderizar la interfaz de usuario basándose en un estado inmutable proporcionado por el ViewModel. Este último actúa como un transformador de datos recibiendo las interacciones del usuario y convirtiéndolas en acciones que invocan casos de uso en la capa de dominio. La comunicación entre estas dos capas se realiza mediante flujos de datos reactivos utilizando StateFlow lo que garantiza que la interfaz de usuario sea siempre consistente y esté sincronizada con el estado actual del sistema sin necesidad de manipular manualmente las vistas.

La inyección de dependencias es un pilar fundamental de la arquitectura de NADIR implementada a través del framework Koin. Esta herramienta ligera y pragmática permite gestionar el ciclo de vida de los componentes de manera eficiente facilitando la creación de instancias y la resolución de dependencias en tiempo de ejecución. En lugar de utilizar generadores de código complejos como Dagger Koin aprovecha las características del lenguaje Kotlin para definir los módulos de inyección de una manera declarativa y legible. Esto simplifica enormemente la configuración del grafo de dependencias permitiendo definir fácilmente qué objetos deben ser únicos o Singletons y cuáles deben crearse cada vez que se solicitan o Factories. Esta flexibilidad es crucial para intercambiar implementaciones durante las pruebas permitiendo por ejemplo inyectar un sensor simulado en lugar del sensor físico del dispositivo.

La capa de dominio representa el núcleo inmutable de la aplicación donde residen las reglas de negocio y los casos de uso. Esta capa es completamente agnóstica de la plataforma Android y no depende de ninguna biblioteca externa preservando la pureza de la lógica empresarial. Los casos de uso como Iniciar Calibración o Evaluar Progreso actúan como orquestadores que coordinan las interacciones entre las entidades del dominio y los repositorios de datos. Al encapsular cada operación de negocio en una clase separada se mejora la legibilidad del código y se facilita la comprensión de qué hace exactamente el sistema sin tener que navegar por implementaciones complejas. Además esta estructura permite aplicar el principio de responsabilidad única de manera estricta donde cada caso de uso tiene una única razón para cambiar.

La capa de datos es la responsable de proporcionar la información necesaria al dominio actuando como un puente hacia las fuentes de datos externas. Aquí se implementan las interfaces de repositorio definidas en la capa de dominio ocultando los detalles concretos de cómo se obtienen o almacenan los datos. Por ejemplo el repositorio de sesiones abstrae la complejidad de interactuar con el acelerómetro del dispositivo o con el servicio de análisis de voz. Esta abstracción permite cambiar la fuente de datos subyacente sin afectar al resto de la aplicación por ejemplo migrando de una base de datos local a un servicio en la nube sin que el dominio o la presentación se enteren del cambio.

El manejo de la concurrencia y las operaciones asíncronas se realiza utilizando Kotlin Coroutines y Flow. Las corutinas proporcionan un modelo de programación concurrente estructurado que simplifica el código asíncrono haciéndolo parecer secuencial. Esto es especialmente importante en Android donde las operaciones de larga duración como la lectura de sensores o el procesamiento de audio no deben bloquear el hilo principal de la interfaz de usuario. Flow complementa a las corutinas ofreciendo un mecanismo robusto para manejar streams de datos asíncronos permitiendo aplicar operadores de transformación filtrado y combinación de manera reactiva. En NADIR el flujo de datos desde el acelerómetro hasta la interfaz de usuario es un claro ejemplo de este paradigma donde los eventos del sensor se emiten en un Flow se procesan en el dominio y finalmente se consumen en la vista.

La interfaz de usuario construida íntegramente con Jetpack Compose representa un cambio significativo respecto al sistema de vistas imperativo tradicional. Compose utiliza un enfoque declarativo donde la interfaz se describe como una función del estado actual. Esto elimina la necesidad de manipular manualmente los widgets de la interfaz reduciendo drásticamente la posibilidad de errores relacionados con el estado inconsistente de la vista. La reutilización de componentes es otro beneficio clave de Compose permitiendo crear una biblioteca de elementos de interfaz coherentes y personalizables que aseguran una experiencia de usuario uniforme en toda la aplicación. Además la integración con las herramientas de diseño y previsualización de Android Studio acelera el ciclo de desarrollo permitiendo iterar rápidamente en el diseño visual.

La gestión de errores y excepciones se aborda de manera centralizada para garantizar que la aplicación responda de manera elegante ante situaciones imprevistas. En lugar de utilizar bloques try catch dispersos por todo el código se utiliza un mecanismo de propagación de errores a través de resultados sellados o Result types. Esto obliga a los consumidores de las funciones a manejar explícitamente los casos de éxito y error mejorando la robustez del código. Los errores críticos se capturan en el nivel más alto de la arquitectura y se presentan al usuario de manera informativa mientras que los errores no críticos se registran silenciosamente para su posterior análisis.

La persistencia de datos cuando es necesaria se maneja mediante Room la biblioteca de base de datos oficial de Android. Room proporciona una capa de abstracción sobre SQLite que verifica las consultas en tiempo de compilación evitando errores de sintaxis SQL en tiempo de ejecución. La integración de Room con corutinas y Flow permite observar los cambios en la base de datos de manera reactiva actualizando automáticamente la interfaz de usuario cuando los datos cambian. En NADIR esto se utiliza para almacenar el historial de sesiones permitiendo al usuario consultar su progreso a lo largo del tiempo.

La seguridad y la privacidad se han integrado en la arquitectura desde el diseño inicial. El acceso a los sensores y al micrófono se gestiona a través de un sistema de permisos robusto que solicita el consentimiento del usuario solo cuando es estrictamente necesario. Los datos sensibles procesados en memoria se limpian tan pronto como dejan de ser necesarios y no se almacenan de forma persistente sin encriptación. La arquitectura modular facilita la auditoría de seguridad permitiendo revisar cada componente de manera aislada para identificar posibles vulnerabilidades.

El sistema de compilación basado en Gradle utiliza un catálogo de versiones centralizado para gestionar las dependencias del proyecto. Esto asegura que todos los módulos utilicen las mismas versiones de las bibliotecas evitando conflictos y problemas de compatibilidad difíciles de depurar. La configuración de los scripts de construcción en Kotlin DSL proporciona un tipado fuerte y un mejor soporte del entorno de desarrollo facilitando la personalización y el mantenimiento de la lógica de construcción.

La testabilidad es un requisito transversal que ha influido en todas las decisiones arquitectónicas. La separación de capas y el uso de inyección de dependencias permiten sustituir cualquier componente real por un doble de prueba o Mock durante los tests. Esto permite verificar la lógica de negocio de manera exhaustiva mediante pruebas unitarias rápidas y fiables sin depender del emulador o del dispositivo físico. Las pruebas de integración verifican la interacción correcta entre los diferentes módulos asegurando que el sistema funcione como un todo coherente.

La escalabilidad de la arquitectura permite que NADIR crezca y evolucione sin comprometer su integridad estructural. La adición de nuevas características como la integración con wearables o el soporte para nuevos idiomas se puede realizar creando nuevos módulos o extendiendo los existentes sin necesidad de refactorizar el núcleo de la aplicación. Esta flexibilidad es esencial para un proyecto vivo que busca adaptarse a las necesidades cambiantes de los usuarios y aprovechar las nuevas tecnologías a medida que surgen.

El rendimiento se ha optimizado en cada capa de la arquitectura. El uso de estructuras de datos inmutables y funciones puras en el dominio facilita la optimización del compilador y reduce el riesgo de condiciones de carrera en entornos concurrentes. En la capa de presentación Compose optimiza inteligentemente la recomposición de la interfaz redibujando solo los elementos que han cambiado y evitando el trabajo innecesario. El perfilado continuo de la aplicación permite identificar y corregir cuellos de botella garantizando una experiencia de usuario fluida incluso en dispositivos de gama media.

En conclusión la arquitectura de NADIR no es un mero esqueleto técnico sino la materialización de una filosofía de diseño que valora la calidad la robustez y la mantenibilidad. Cada decisión desde la elección de Clean Architecture hasta la adopción de Jetpack Compose ha sido tomada con el objetivo de crear un sistema sólido que sirva eficazmente a su propósito terapéutico proporcionando al mismo tiempo una base firme para el crecimiento futuro. Es una arquitectura que respeta los estándares de la industria pero que se adapta pragmáticamente a las necesidades específicas del proyecto demostrando que la excelencia técnica es el mejor cimiento para la innovación funcional.
